<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Tutorial: Protocol Buffer Basics</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/atom-one-dark.css" /><script type="text/javascript" src="highlight/highlight.pack.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with the <a href="https://github.com/clojang/codox-theme">Clojang UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">protobuf</span> <span class="project-version">3.5.1-v1.1-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="1000-basic-usage.html"><div class="inner"><span>Basic Usage</span></div></a></li><li class="depth-1  current"><a href="1050-tutorial.html"><div class="inner"><span>Tutorial: Protocol Buffer Basics</span></div></a></li><li class="depth-1 "><a href="1100-extensions.html"><div class="inner"><span>Extensions</span></div></a></li><li class="depth-1 "><a href="9800-marginalia.html"><div class="inner"><span>Marginalia</span></div></a></li><li class="depth-1 "><a href="9900-javadoc.html"><div class="inner"><span>javadoc</span></div></a></li><li class="depth-1 "><a href="9999-other-versions.html"><div class="inner"><span>Other Versions</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protobuf</span></div></div></li><li class="depth-2 branch"><a href="protobuf.common.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>common</span></div></a></li><li class="depth-2 branch"><a href="protobuf.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>impl</span></div></div></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>flatland</span></div></div></li><li class="depth-4 branch"><a href="protobuf.impl.flatland.codec.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>codec</span></div></a></li><li class="depth-4 branch"><a href="protobuf.impl.flatland.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-4 branch"><a href="protobuf.impl.flatland.map.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>map</span></div></a></li><li class="depth-4 branch"><a href="protobuf.impl.flatland.mapdef.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mapdef</span></div></a></li><li class="depth-4"><a href="protobuf.impl.flatland.schema.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>schema</span></div></a></li><li class="depth-2"><a href="protobuf.util.html"><div class="inner"><span class="tree" style="top: -207px;"><span class="top" style="height: 216px;"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#tutorial-protocol-buffer-basics" name="tutorial-protocol-buffer-basics"></a>Tutorial: Protocol Buffer Basics</h1>
<p><em>Note: The majority of the content for this tutorial was taken from the <a href="https://developers.google.com/protocol-buffers/docs/javatutorial">official Google protobuf Java tutorial</a>, with additions, removals, and other changes.</em></p>
<h2><a href="#introduction" name="introduction"></a>Introduction</h2>
<p>This tutorial provides a basic Clojure programmer’s introduction to working with protocol buffers. By walking through creating a simple example application, it shows you how to:</p>
<ul>
  <li>Define message formats in a <code>.proto</code> file.</li>
  <li>Use the protocol buffer compiler.</li>
  <li>Use the Clojure protocol buffer API to write and read messages.</li>
</ul>
<p>This isn’t a comprehensive guide to using protocol buffers in Clojure. For more detailed reference information, see:</p>
<ul>
  <li>the <a href="https://developers.google.com/protocol-buffers/docs/proto">Protocol Buffer Language Guide</a></li>
  <li>the <a href="https://clojusc.github.io/protobuf">Clojure API Reference</a></li>
  <li>the <a href="https://developers.google.com/protocol-buffers/docs/encoding">Encoding Reference</a></li>
</ul>
<p>Additionally, you may find these useful:</p>
<ul>
  <li>the <a href="https://developers.google.com/protocol-buffers/docs/reference/java/index.html">Java API Reference</a></li>
  <li>the <a href="https://developers.google.com/protocol-buffers/docs/reference/java-generated">Java Generated Code Guide</a></li>
</ul>
<h2><a href="#why-use-protocol-buffers-" name="why-use-protocol-buffers-"></a>Why Use Protocol Buffers?</h2>
<p>Protocol buffers solve the problem of efficiently serializing and deserializing structured data in a language-agnostic manner, accessible a vast array of applications (as long as the applications are written in a language that has a protobuf library). We’ll illustrate this with an example.</p>
<p>The example we’re going to use is a very simple “address book” application that can read and write people’s contact details to and from a file. Each person in the address book has a name, an ID, an email address, and a contact phone number.</p>
<p>So, how might one serialize and retrieve structured data like this if protobuf wasn’t around? There are a few ways to solve this problem:</p>
<ul>
  <li>Use Java Serialization. This is the default approach since it’s built into the language, but it has a host of well-known problems (see Effective Java, by Josh Bloch pp. 213), and also doesn’t work very well if you need to share data with applications written in C++ or Python.</li>
  <li>You can invent an ad-hoc way to encode the data items into a single string – such as encoding 4 ints as “12:3:-23:67”. This is a simple and flexible approach, although it does require writing one-off encoding and parsing code, and the parsing imposes a small run-time cost. This works best for encoding very simple data.</li>
  <li>Serialize the data to XML. This approach can be very attractive since XML is (sort of) human readable and there are binding libraries for lots of languages. This can be a good choice if you want to share data with other applications/projects. However, XML is notoriously space intensive, and encoding/decoding it can impose a huge performance penalty on applications. Also, navigating an XML DOM tree is considerably more complicated than navigating simple fields in a class normally would be.</li>
</ul>
<p>To avoid the problems mentioned in each of the above (as well as many others), protocol buffers was created. They are the flexible, efficient, automated solution.</p>
<p>With protocol buffers, you write a <code>.proto</code> description of the data structure you wish to store. From that, the protocol buffer compiler creates compilable source code that implements automatic encoding and parsing of the protocol buffer data with an efficient binary format. The generated code provides getters and setters for the fields that make up a protocol buffer and takes care of the details of reading and writing the protocol buffer as a unit. Importantly, the protocol buffer format supports the idea of extending the format over time in such a way that the code can still read data encoded with the old format.</p>
<h2><a href="#defining-your-protocol-format" name="defining-your-protocol-format"></a>Defining Your Protocol Format</h2>
<p>To create your address book application, you’ll need to start with a <code>.proto</code> file. The definitions in a <code>.proto</code> file are simple: you add a message for each data structure you want to serialize, then specify a name and a type for each field in the message. Here is the <code>.proto</code> file that defines your messages, <code>addressbook.proto</code>:</p>
<pre><code class="proto">syntax = "proto2";

package tutorial;

option java_package = "protobuf.examples.tutorial";
option java_outer_classname = "AddressBookProtos";

message Person {
  required string name = 1;
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phones = 4;
}

message AddressBook {
  repeated Person people = 1;
}
</code></pre>
<p>(Additionally, this file has been made available for you in the <code>resources/proto/examples</code> directory of the Clojure protobuf project.)</p>
<p>As you can see, the syntax is similar to C++ or Java. Let’s go through each part of the file and see what it does.</p>
<p>The <code>.proto</code> file starts with a package declaration, which helps to prevent naming conflicts between different projects. In Java, the package name is used as the Java package unless you have explicitly specified a <code>java_package</code>, as we have here. Even if you do provide a <code>java_package</code>, you should still define a normal package as well to avoid name collisions in the Protocol Buffers name space as well as in non-Java languages.</p>
<p></p><blockquote> After the package declaration, you can see two options that are Java-specific. Thanks to Clojure’s Java inter-op, we can take advantage of this directly, without writing our own Clojure protobuf compiler or waiting for Google to support Clojure. </blockquote><p></p>
<p><code>java_package</code> specifies in what Java package name your generated classes should live. If you don’t specify this explicitly, it simply matches the package name given by the package declaration, but these names usually aren’t appropriate Java package names (since they usually don’t start with a domain name).</p>
<p>The <code>java_outer_classname</code> option defines the class name which should contain all of the classes in this file. If you don’t give a <code>java_outer_classname</code> explicitly, it will be generated by converting the file name to camel case. For example, <code>my_proto.proto</code> would, by default, use <code>MyProto</code> as the outer class name.</p>
<p>Next, you have your message definitions. A message is just an aggregate containing a set of typed fields. Many standard simple data types are available as field types, including <code>bool</code>, <code>int32</code>, <code>float</code>, <code>double</code>, and <code>string.</code> You can also add further structure to your messages by using other message types as field types – in the above example the <code>Person</code> message contains <code>PhoneNumber</code> messages, while the <code>AddressBook</code> message contains <code>Person</code> messages. You can even define message types nested inside other messages – as you can see, the <code>PhoneNumber</code> type is defined inside <code>Person</code>. You can also define <code>enum</code> types if you want one of your fields to have one of a predefined list of values – here you want to specify that a phone number can be one of <code>MOBILE</code>, <code>HOME</code>, or <code>WORK</code>.</p>
<p>The “ = 1”, “ = 2” markers on each element identify the unique “tag” that field uses in the binary encoding. Tag numbers 1-15 require one less byte to encode than higher numbers, so as an optimization you can decide to use those tags for the commonly used or repeated elements, leaving tags 16 and higher for less-commonly used optional elements. Each element in a repeated field requires re-encoding the tag number, so repeated fields are particularly good candidates for this optimization.</p>
<p>Each field must be annotated with one of the following modifiers:</p>
<ul>
  <li><code>required</code>: a value for the field must be provided, otherwise the message will be considered “uninitialized”. Trying to build an uninitialized message will throw a <code>RuntimeException</code>. Parsing an uninitialized message will throw an <code>IOException</code>. Other than this, a required field behaves exactly like an optional field.</li>
  <li><code>optional</code>: the field may or may not be set. If an optional field value isn’t set, a default value is used. For simple types, you can specify your own default value, as we’ve done for the phone number type in the example. Otherwise, a system default is used: zero for numeric types, the empty string for strings, <code>false</code> for bools. For embedded messages, the default value is always the “default instance” or “prototype” of the message, which has none of its fields set. Calling the accessor to get the value of an optional (or required) field which has not been explicitly set always returns that field’s default value.</li>
  <li><code>repeated</code>: the field may be repeated any number of times (including zero). The order of the repeated values will be preserved in the protocol buffer. Think of repeated fields as dynamically sized arrays.</li>
</ul>
<p></p><blockquote> <strong>Required Is Forever</strong><p></p>
<p>You should be very careful about marking fields as required. If at some point you wish to stop writing or sending a required field, it will be problematic to change the field to an optional field – old readers will consider messages without this field to be incomplete and may reject or drop them unintentionally. You should consider writing application-specific custom validation routines for your buffers instead. Some engineers at Google have come to the conclusion that using required does more harm than good; they prefer to use only optional and repeated. However, this view is not universal. </p></blockquote><p></p>
<p>You’ll find a complete guide to writing <code>.proto</code> files – including all the possible field types – in the <a href="https://developers.google.com/protocol-buffers/docs/proto">Protocol Buffer Language Guide</a>. Don’t go looking for facilities similar to class inheritance, though – protocol buffers don’t do that.</p>
<h2><a href="#compiling-your-protocol-buffers" name="compiling-your-protocol-buffers"></a>Compiling Your Protocol Buffers</h2>
<p>Now that you have a <code>.proto</code>, the next thing you need to do is generate the classes you’ll need to read and write <code>AddressBook</code> (and hence <code>Person</code> and <code>PhoneNumber</code>) messages. To do this, you need to run the protocol buffer compiler <code>protoc</code> on your <code>.proto</code>:</p>
<ol>
  <li>If you haven’t installed this yet, now is the time. Your operating system’s  package manager very likely already provides a version for you – search  there first. If not, you can <a href="https://developers.google.com/protocol-buffers/docs/downloads.html">download it</a> from Google.</li>
  <li>Now run the compiler, specifying:</li>
</ol>
<ul>
  <li>the source directory (where your application’s source code lives – the  current directory is used if you don’t provide a value)</li>
  <li>the destination directory (where you want the generated code to go; often  the same as $SRC_DIR), and</li>
  <li>the path to your <code>.proto.</code></li>
</ul>
<p>In this case:</p>
<pre><code class="bash">$ protoc -I=resources --java_out=target/examples \
  resources/protobuf/examples/tutorial.proto
</code></pre>
<p>This gives us:</p>
<pre><code class="bash">$ ls -1 target/examples/protobuf/examples/tutorial/
AddressBookProtos.java
</code></pre>
<p>To have <code>lein</code> compile protobuf <code>.java</code> source files to <code>.class</code> that can be used from Clojure, we need to make sure that <code>lein</code> knows about our Java sources – with do this with the <code>:java-source-paths</code> key in the <code>project.clj</code> file, either at the top-level or in an appropriate profile.</p>
<p>For example, this is what the Clojure protobuf project has set, using the <code>:test</code> profile:</p>
<pre><code class="clj">:test {
  :java-source-paths [
    "target/examples"
    "target/testing"]}
</code></pre>
<p></p><blockquote> Fore convenience, the Clojure protobuf project always compiles the examples and the tests before starting up the REPL, so they are always freshly available to developers. </blockquote><p></p>
<h2><a href="#the-protocol-buffer-api" name="the-protocol-buffer-api"></a>The Protocol Buffer API</h2>
<p>Let’s fire up the REPL and see how to use the compiled code from Clojure:</p>
<pre><code class="bash">$ lein repl
</code></pre>
<h3><a href="#setup" name="setup"></a>Setup</h3>
<p>First we’ll pull in the Clojure API:</p>
<pre><code class="clj">[protobuf.dev] λ=&gt; (require '[clojure.java.io :as io]
                            '[protobuf.core :as protobuf])
nil
</code></pre>
<p>Then we’ll import the generated Java classes we want to use:</p>
<pre><code class="clj">[protobuf.dev] λ=&gt; (import '(protobuf.examples.tutorial
                             AddressBookProtos$Person
                             AddressBookProtos$Person$PhoneNumber
                             AddressBookProtos$AddressBook))
protobuf.examples.tutorial.AddressBookProtos$AddressBook
</code></pre>
<p>Note that for nested inner classes, we simply keep using the inner class separator <code>$</code> of Clojure’s Java inter-op.</p>
<p>We can view the full, nested data schema in Clojure data:</p>
<pre><code class="clj">[protobuf.dev] λ=&gt; (pprint (protobuf/schema AddressBookProtos$AddressBook))
{:type :struct,
 :name "tutorial.AddressBook",
 :fields
 {:people
  {:type :list,
   :values
   {:type :struct,
    :name "tutorial.Person",
    :fields
    {:name {:type :string},
     :id {:type :int},
     :email {:type :string},
     :phones
     {:type :list,
      :values
      {:type :struct,
       :name "tutorial.Person.PhoneNumber",
       :fields
       {:number {:type :string},
        :type
        {:type :enum,
         :values #{:home :work :mobile},
         :default
         #object[com.google.protobuf.Descriptors$EnumValueDescriptor 0x1df8368f "HOME"]}}}}}}}}}
nil
</code></pre>
<p></p><blockquote> There’s currently a bug/missing feature where the default value of an <code>enum</code> is not converted to Clojure data. For current status on this issue, see: <a href="https://github.com/clojusc/protobuf/issues/22"></a><a href="https://github.com/clojusc/protobuf/issues/22">https://github.com/clojusc/protobuf/issues/22</a> </blockquote><p></p>
<h2><a href="#the" name="the"></a>The <code>ProtoBufAPI</code></h2>
<p>The following methods all take an instance of <code>protobuf.core.ProtoBufAPI</code> as their first argument. An example implementation is <code>protobuf.impl.flatland.core.FlatlandProtoBuf</code>.</p>
<p>Note that the constructor is not a method, and as such, does not take a <code>ProtoBufAPI</code> instance as its first arguement.</p>
<h3><a href="#instantiation" name="instantiation"></a>Instantiation</h3>
<ul>
  <li><code>protobuf/create</code> - Takes a compiled protocol buffer class, as created by the  <code>protoc</code> compiler, as well as the data (fields) to use in creating the  protocol buffer message for the class. Returns a <code>protobuf.core.ProtoBufAPI</code>  implementation</li>
</ul>
<h3><a href="#serialization-and-deserialization" name="serialization-and-deserialization"></a>Serialization and Deserialization</h3>
<ul>
  <li><code>protobuf/-&gt;bytes</code> - Given an instance of a Clojure ProtoBuf, convert its message to  an array of raw bytes; this is the serialization method.</li>
  <li><code>protobuf/bytes-&gt;</code> - Given an array or stream of bytes, convert it  to a Clojure ProtoBuf instance; this is the deserialization method.</li>
</ul>
<h3><a href="#reading-and-writing" name="reading-and-writing"></a>Reading and Writing</h3>
<ul>
  <li><code>protobuf/read</code> - Given an instance of a Clojure ProtoBuf and an input  object (anthying that can be coerced to a <code>InputStream</code>), read from the input  and return a Clojure ProtoBuf.</li>
  <li><code>protobuf/write</code> - Given an instance of a Clojure ProtoBuf and an output  object (anthying that can be coerced to a <code>OutputStream</code>), write the  serialized bytes of the instance to the output.</li>
</ul>
<h3><a href="#inspection" name="inspection"></a>Inspection</h3>
<ul>
  <li><code>protobuf/-&gt;schema</code> - Given an instance of a Clojure ProtoBuf, return the  data for its protocol buffer schema.</li>
</ul>
<h2><a href="#example-usage" name="example-usage"></a>Example Usage</h2>
<h3><a href="#creating-messages" name="creating-messages"></a>Creating Messages</h3>
<p>The <code>create</code> function generates the appropriate protocol buffer message. We’ll use that now to create a list of <code>PhoneNumber</code> messages:</p>
<pre><code class="clj">[protobuf.dev] λ=&gt; (def phones [(protobuf/create AddressBookProtos$Person$PhoneNumber
                                                 {:number "555-1212" :type :home})
                                (protobuf/create AddressBookProtos$Person$PhoneNumber
                                                 {:number "555-1213" :type :mobile})
                                (protobuf/create AddressBookProtos$Person$PhoneNumber
                                                 {:number "555-1214" :type :work})])
#'protobuf.dev/phones
</code></pre>
<p></p><blockquote> Note that currently only lower-case enum values are supported by Clojure protobuf; if you create <code>.proto</code> files with enum fields whose values contain any capital letters, your code will be unstable and likely eventually break.<p></p>
<p>For current status on this issue, see <a href="https://github.com/clojusc/protobuf/issues/25"></a><a href="https://github.com/clojusc/protobuf/issues/25">https://github.com/clojusc/protobuf/issues/25</a> </p></blockquote><p></p>
<p>Now we can use these when creating our <code>Person</code> message:</p>
<pre><code class="clj">[protobuf.dev] λ=&gt; (def alice (protobuf/create AddressBookProtos$Person
                                               {:id 108
                                                :name "Alice"
                                                :email "alice@example.com"
                                                :phones phones}))
#'protobuf.dev/alice
</code></pre>
<p>And then that can be used when creating (or updating) an <code>AddressBook</code> message:</p>
<pre><code class="clj">[protobuf.dev] λ=&gt; (def addresses (protobuf/create AddressBookProtos$AddressBook
                                                   {:people [alice]}))
#'protobuf.dev/addresses
</code></pre>
<p>Let’s take a quick look at the result:</p>
<pre><code class="clj">[protobuf.dev] λ=&gt; (pprint addresses)
{:people
 [{:name "Alice",
   :id 108,
   :email "alice@example.com",
   :phones
   [{:number "555-1212", :type :home}
    {:number "555-1213", :type :mobile}
    {:number "555-1214", :type :work}]}]}
nil
</code></pre>
<h3><a href="#writing-a-messages" name="writing-a-messages"></a>Writing a Messages</h3>
<p>These can then be written to an output stream:</p>
<pre><code class="clj">[protobuf.dev] λ=&gt; (protobuf/write addresses "/tmp/address-book.db")
nil
</code></pre>
<p>Note that the first argument doesn’t have to be a string representing a file name; it can be anything which <code>clojure.java.io/output-stream</code> can coerce to a stream (e.g., <code>OutputStream</code>, <code>File</code>, <code>URI</code>, <code>URL</code>, <code>Socket</code>, or <code>String</code>).</p>
<p>Take a look at the contents of <code>/tmp/address-book.db</code> to convince yourself the the data was actually written there. Then, we’ll try reading it back in …</p>
<h3><a href="#reading-a-message" name="reading-a-message"></a>Reading a Message</h3>
<p>Reading stored protobuf data is just as easy as writing it:</p>
<pre><code class="clj">[protobuf.dev] λ=&gt; (def address-book (protobuf/read addresses "/tmp/address-book.db"))
#'protobuf.dev/address-book
[protobuf.dev] λ=&gt; (= addresses address-book)
true
</code></pre>
<h2><a href="#extending-a-protocol" name="extending-a-protocol"></a>Extending a Protocol</h2>
<p>Sooner or later after you release the code that uses your protocol buffer, you will undoubtedly want to “improve” the protocol buffer’s definition. If you want your new buffers to be backwards-compatible, and your old buffers to be forward-compatible – and you almost certainly do want this – then there are some rules you need to follow. In the new version of the protocol buffer:</p>
<ul>
  <li>you <strong>must not</strong> change the tag numbers of any existing fields.</li>
  <li>you <strong>must not</strong> add or delete any required fields.</li>
  <li>you <em>may</em> delete optional or repeated fields.</li>
  <li>you <em>may</em> add new optional or repeated fields but you must use fresh tag  numbers (i.e. tag numbers that were never used in this protocol buffer,  not even by deleted fields).</li>
</ul>
<p>If you follow these rules, old code will happily read new messages and simply ignore any new fields. To the old code, optional fields that were deleted will simply have their default value, and deleted repeated fields will be empty. New code will also transparently read old messages. However, keep in mind that new optional fields will not be present in old messages, so you will need to either check explicitly whether they’re set or provide a reasonable default value in your <code>.proto</code> file with <code>[default = value]</code> after the tag number.</p>
<p>If the default value is not specified for an optional element, a type-specific default value is used instead: for strings, the default value is the empty string. For booleans, the default value is <code>false</code>. For numeric types, the default value is zero. Note also that if you added a new repeated field, your new code will not be able to tell whether it was left empty (by new code) or never set at all (by old code).</p>
<h2><a href="#advanced-usage" name="advanced-usage"></a>Advanced Usage</h2>
<p>Protocol buffers have uses that go beyond simple accessors and serialization. Be sure to explore the <a href="https://developers.google.com/protocol-buffers/docs/reference/java/index.html">Java API reference</a> to see what else you can do with them.</p>
<p>One key feature provided by protocol message classes is <code>reflection</code>. You can iterate over the fields of a message and manipulate their values without writing your code against any specific message type. One very useful way to use reflection is for converting protocol messages to and from other encodings, such as XML or JSON. A more advanced use of reflection might be to find differences between two messages of the same type, or to develop a sort of “regular expressions for protocol messages” in which you can write expressions that match certain message contents. If you use your imagination, it’s possible to apply Protocol Buffers to a much wider range of problems than you might initially expect!</p>
<!-- Named page links below: /--></div></div></div></body></html>